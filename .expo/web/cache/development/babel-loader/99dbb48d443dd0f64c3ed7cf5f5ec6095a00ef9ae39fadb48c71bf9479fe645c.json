{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { getFirestore, collection, doc, getDoc, query, where, getDocs, deleteDoc, updateDoc } from 'firebase/firestore';\nexport var fetchCanalUsers = createAsyncThunk('canals/fetchCanalUsers', function () {\n  var _ref = _asyncToGenerator(function* (canalId) {\n    var db = getFirestore();\n    var canalRef = doc(db, 'canals', canalId);\n    var canalSnapshot = yield getDoc(canalRef);\n    var canalData = canalSnapshot.data();\n    var usersQuery = query(collection(db, 'userCanals'), where('canalId', '==', canalId));\n    var usersSnapshot = yield getDocs(usersQuery);\n    var usersData = [];\n    for (var userDoc of usersSnapshot.docs) {\n      var userCanalData = userDoc.data();\n      var userId = userCanalData.userId;\n      var userRef = doc(db, 'users', userId);\n      var userSnapshot = yield getDoc(userRef);\n      if (userSnapshot.exists()) {\n        var userData = _objectSpread(_objectSpread({\n          id: userId\n        }, userSnapshot.data()), {}, {\n          isAdmin: false\n        });\n        if (Array.isArray(canalData.role)) {\n          for (var role of canalData.role) {\n            if (role.uid === userId && role.isAdmin) {\n              userData.isAdmin = true;\n              break;\n            }\n          }\n        }\n        usersData.push(userData);\n      }\n    }\n    return usersData;\n  });\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}());\nexport var removeUserFromCanal = createAsyncThunk('canals/removeUserFromCanal', function () {\n  var _ref3 = _asyncToGenerator(function* (_ref2) {\n    var userId = _ref2.userId,\n      canalId = _ref2.canalId;\n    var db = getFirestore();\n    var userCanalQuery = query(collection(db, 'userCanals'), where('userId', '==', userId), where('canalId', '==', canalId));\n    var userCanalSnapshot = yield getDocs(userCanalQuery);\n    if (!userCanalSnapshot.empty) {\n      var docId = userCanalSnapshot.docs[0].id;\n      yield deleteDoc(doc(db, 'userCanals', docId));\n    } else {\n      throw new Error('La liaison entre l\\'utilisateur et l\\'canal n\\'a pas été trouvée');\n    }\n    var canalRef = doc(db, 'canals', canalId);\n    var canalSnap = yield getDoc(canalRef);\n    if (canalSnap.exists) {\n      var canalData = canalSnap.data();\n      var filteredRoles = canalData.role.filter(function (role) {\n        return role.uid !== userId;\n      });\n      yield updateDoc(canalRef, {\n        role: filteredRoles\n      });\n    } else {\n      throw new Error('L\\'canal n\\'a pas été trouvée');\n    }\n  });\n  return function (_x2) {\n    return _ref3.apply(this, arguments);\n  };\n}());\nvar canalUsersSlice = createSlice({\n  name: 'canalUsers',\n  initialState: {\n    status: 'idle',\n    data: [],\n    error: null\n  },\n  reducers: {},\n  extraReducers: function extraReducers(builder) {\n    builder.addCase(fetchCanalUsers.pending, function (state) {\n      state.status = 'loading';\n    }).addCase(fetchCanalUsers.fulfilled, function (state, action) {\n      state.status = 'succeeded';\n      state.data = action.payload;\n    }).addCase(fetchCanalUsers.rejected, function (state, action) {\n      state.status = 'failed';\n      state.error = action.error.message;\n    });\n  }\n});\nexport default canalUsersSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","getFirestore","collection","doc","getDoc","query","where","getDocs","deleteDoc","updateDoc","fetchCanalUsers","_ref","_asyncToGenerator","canalId","db","canalRef","canalSnapshot","canalData","data","usersQuery","usersSnapshot","usersData","userDoc","docs","userCanalData","userId","userRef","userSnapshot","exists","userData","_objectSpread","id","isAdmin","Array","isArray","role","uid","push","_x","apply","arguments","removeUserFromCanal","_ref3","_ref2","userCanalQuery","userCanalSnapshot","empty","docId","Error","canalSnap","filteredRoles","filter","_x2","canalUsersSlice","name","initialState","status","error","reducers","extraReducers","builder","addCase","pending","state","fulfilled","action","payload","rejected","message","reducer"],"sources":["C:/Users/Benoitm/Documents/Coding/Kappze/MyKappze/src/features/canals/canalUsersSlice.tsx"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\r\nimport { getFirestore, collection, doc, getDoc, query, where, getDocs, deleteDoc, updateDoc } from 'firebase/firestore';\r\n\r\n\r\ninterface User {\r\n    id: string;\r\n    isAdmin: boolean;\r\n    // Inclure ici d'autres propriétés de l'utilisateur si nécessaire\r\n  }\r\n  \r\n  interface Role {\r\n    uid: string;\r\n    isAdmin: boolean;\r\n  }\r\n  \r\n  interface CanalData {\r\n    role: Role[];\r\n  }\r\n  \r\n  export const fetchCanalUsers = createAsyncThunk<\r\n    User[], // Le type de la valeur de retour de la promesse\r\n    string, // Le type du payload\r\n    {} // Le type des informations de rejet si la promesse est rejetée\r\n  >('canals/fetchCanalUsers', async (canalId) => {\r\n    const db = getFirestore();\r\n  \r\n    // Get the canal data\r\n    const canalRef = doc(db, 'canals', canalId);\r\n    const canalSnapshot = await getDoc(canalRef);\r\n    const canalData = canalSnapshot.data() as CanalData;\r\n  \r\n    // Get the users associated with this canal\r\n    const usersQuery = query(collection(db, 'userCanals'), where('canalId', '==', canalId));\r\n    const usersSnapshot = await getDocs(usersQuery);\r\n  \r\n    const usersData: User[] = [];\r\n    for (const userDoc of usersSnapshot.docs) {\r\n      const userCanalData = userDoc.data();\r\n      const userId = userCanalData.userId;\r\n  \r\n      // Get the user's information from its reference\r\n      const userRef = doc(db, 'users', userId);\r\n      const userSnapshot = await getDoc(userRef);\r\n  \r\n      if (userSnapshot.exists()) {\r\n        const userData: User = { id: userId, ...userSnapshot.data(), isAdmin: false };\r\n  \r\n        // Check if the user is an admin\r\n        if (Array.isArray(canalData.role)) {\r\n          for (let role of canalData.role) {\r\n            if (role.uid === userId && role.isAdmin) {\r\n              userData.isAdmin = true;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n  \r\n        usersData.push(userData);\r\n      }\r\n    }\r\n  \r\n    return usersData;\r\n  });\r\n\r\n\r\nexport const removeUserFromCanal = createAsyncThunk(\r\n    'canals/removeUserFromCanal',\r\n    async ({ userId, canalId }) => {\r\n        const db = getFirestore();\r\n\r\n        // Query to get the document ID of the user-canal link\r\n        const userCanalQuery = query(collection(db, 'userCanals'), where('userId', '==', userId), where('canalId', '==', canalId));\r\n        const userCanalSnapshot = await getDocs(userCanalQuery);\r\n\r\n        if (!userCanalSnapshot.empty) {\r\n            // Assuming there is only one document that matches the query\r\n            const docId = userCanalSnapshot.docs[0].id;\r\n\r\n            // Delete the document\r\n            await deleteDoc(doc(db, 'userCanals', docId));\r\n        } else {\r\n            throw new Error('La liaison entre l\\'utilisateur et l\\'canal n\\'a pas été trouvée');\r\n        }\r\n\r\n        // Get the canal document\r\n        const canalRef = doc(db, 'canals', canalId);\r\n        const canalSnap = await getDoc(canalRef);\r\n        \r\n        if (canalSnap.exists) {\r\n            // Filter out the user from the roles array\r\n            const canalData = canalSnap.data();\r\n            const filteredRoles = canalData.role.filter(role => role.uid !== userId);\r\n\r\n            // Update the canal document with the filtered roles array\r\n            await updateDoc(canalRef, { role: filteredRoles });\r\n        } else {\r\n            throw new Error('L\\'canal n\\'a pas été trouvée');\r\n        }\r\n    }\r\n);\r\n\r\n\r\n\r\n\r\nconst canalUsersSlice = createSlice({\r\n    name: 'canalUsers',\r\n    initialState: {\r\n        status: 'idle',\r\n        data: [],\r\n        error: null,\r\n    },\r\n    reducers: {},\r\n    extraReducers: (builder) => {\r\n        builder\r\n            .addCase(fetchCanalUsers.pending, (state) => {\r\n                state.status = 'loading';\r\n            })\r\n            .addCase(fetchCanalUsers.fulfilled, (state, action) => {\r\n                state.status = 'succeeded';\r\n                // console.log(state.data)\r\n                state.data = action.payload;\r\n            })\r\n            .addCase(fetchCanalUsers.rejected, (state, action) => {\r\n                state.status = 'failed';\r\n                state.error = action.error.message;\r\n            });\r\n    },\r\n});\r\n\r\nexport default canalUsersSlice.reducer;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}